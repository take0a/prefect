---
title: Prefect ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ç”¨
description: "`PrefectClient` ã‚’ä½¿ç”¨ã—ã¦ API ã¨å¯¾è©±ã™ã‚‹æ–¹æ³•ã‚’å­¦ã³ã¾ã™ã€‚"
---

## æ¦‚è¦

[`PrefectClient`](https://reference.prefect.io/prefect/client/) ã¯ã€SDK ã§ã¯æŠ½è±¡åŒ–ã§ããªã„å¯èƒ½æ€§ã®ã‚ã‚‹ã€Prefect ã® REST API ã«å¯¾ã™ã‚‹ä¸€èˆ¬çš„ãªæ“ä½œã‚’ç°¡ç´ åŒ–ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™ã€‚

ä¾‹ãˆã°ã€[ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«](/v3/develop/interact-with-api/#reschedule-late-flow-runs) ã™ã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
- `flowRunFilter` ã‚’æŒ‡å®šã—ãŸ `read_flow_runs` ã§ç‰¹å®šã®ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’èª­ã¿å–ã‚Šã¾ã™ã€‚
- `create_flow_run_from_deployment` ã§æ–°ã—ã„ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¾ã™ã€‚
- `delete_flow_run` ã§éå¸¸ã«é…ã‚Œã¦ã„ã‚‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å‰Šé™¤ã—ã¾ã™ã€‚



### ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å–å¾—

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€`get_client()` ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹éåŒæœŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’è¿”ã—ã¾ã™ãŒã€åŒæœŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

<CodeGroup>

```python async
from prefect import get_client

async with get_client() as client:
    response = await client.hello()
    print(response.json()) # ğŸ‘‹
```

You can also use a synchronous client:

```python sync
from prefect import get_client

with get_client(sync_client=True) as client:
    response = client.hello()
    print(response.json()) # ğŸ‘‹
```

</CodeGroup>

## ä¾‹

ã“ã‚Œã‚‰ã®ä¾‹ã¯ã€API ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ç‹¬è‡ªã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’é–‹ç™ºã™ã‚‹æ–¹æ³•ã‚’ç¤ºã™ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦ã„ã¾ã™ã€‚

<Note>
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¸è¶³ã—ã¦ã„ã‚‹ã¨æ€ã‚ã‚Œã‚‹å ´åˆã€ã¾ãŸã¯ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ SDK å…¨ä½“ã§ã‚ˆã‚Šé©åˆ‡ã«è¡¨ç¾ã—ãŸã„å ´åˆã¯ã€[å•é¡Œã‚’é–‹ã„ã¦ãã ã•ã„](https://github.com/PrefectHQ/prefect/issues/new/choose)ã€‚
</Note>

### é…å»¶ã—ã¦ã„ã‚‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã®å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

é…å»¶ã—ã¦ã„ã‚‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’ä¸€æ‹¬ã§å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹ã«ã¯ã€é…å»¶ã—ã¦ã„ã‚‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å‰Šé™¤ã—ã€é…å»¶ã‚’è¨­å®šã—ãŸã€Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ¸ˆã¿ã€çŠ¶æ…‹ã®æ–°ã—ã„ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’ä½œæˆã—ã¾ã™ã€‚
ã“ã‚Œã¯ã€ä¾‹ãˆã°ã€ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’èª¤ã£ã¦éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ¼ãƒ«ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¦ã—ã¾ã£ãŸå ´åˆãªã©ã«ä¾¿åˆ©ã§ã™ã€‚

æ¬¡ã®ä¾‹ã§ã¯ã€ã€Œhealthcheck-storage-testã€ã¨ã„ã†ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®æœ€å¾Œã®3ã¤ã®é…å»¶ã—ã¦ã„ã‚‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’ã€å…ƒã®äºˆå®šé–‹å§‹æ™‚åˆ»ã‹ã‚‰6æ™‚é–“å¾Œã«å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¾ã™ã€‚
ã¾ãŸã€ãã®ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®æ®‹ã‚Šã®é…å»¶ã—ã¦ã„ã‚‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚‚å‰Šé™¤ã—ã¾ã™ã€‚

ã¾ãšã€å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚

```python
async def reschedule_late_flow_runs(
    deployment_name: str,
    delay: timedelta,
    most_recent_n: int,
    delete_remaining: bool = True,
    states: list[str] | None = None
) -> list[FlowRun]:
    states = states or ["Late"]

    async with get_client() as client:
        flow_runs = await client.read_flow_runs(
            flow_run_filter=FlowRunFilter(
                state=dict(name=dict(any_=states)),
                expected_start_time=dict(before_=datetime.now(timezone.utc)),
            ),
            deployment_filter=DeploymentFilter(name={'like_': deployment_name}),
            sort=FlowRunSort.START_TIME_DESC,
            limit=most_recent_n if not delete_remaining else None
        )

        rescheduled_flow_runs: list[FlowRun] = []
        for i, run in enumerate(flow_runs):
            await client.delete_flow_run(flow_run_id=run.id)
            if i < most_recent_n:
                new_run = await client.create_flow_run_from_deployment(
                    deployment_id=run.deployment_id,
                    state=Scheduled(scheduled_time=run.expected_start_time + delay),
                )
                rescheduled_flow_runs.append(new_run)
            
        return rescheduled_flow_runs
```

æ¬¡ã«ã€ã“ã‚Œã‚’ä½¿ç”¨ã—ã¦ãƒ•ãƒ­ãƒ¼ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å¤‰æ›´ã—ã¾ã™:

```python
rescheduled_flow_runs = asyncio.run(
    reschedule_late_flow_runs(
        deployment_name="healthcheck-storage-test",
        delay=timedelta(hours=6),
        most_recent_n=3,
    )
)
```

<Accordion title="View the complete example">

```python reschedule_late_flows.py
from __future__ import annotations

import asyncio
from datetime import datetime, timedelta, timezone

from prefect import get_client
from prefect.client.schemas.filters import DeploymentFilter, FlowRunFilter
from prefect.client.schemas.objects import FlowRun
from prefect.client.schemas.sorting import FlowRunSort
from prefect.states import Scheduled

async def reschedule_late_flow_runs(
    deployment_name: str,
    delay: timedelta,
    most_recent_n: int,
    delete_remaining: bool = True,
    states: list[str] | None = None
) -> list[FlowRun]:
    states = states or ["Late"]

    async with get_client() as client:
        flow_runs = await client.read_flow_runs(
            flow_run_filter=FlowRunFilter(
                state=dict(name=dict(any_=states)),
                expected_start_time=dict(before_=datetime.now(timezone.utc)),
            ),
            deployment_filter=DeploymentFilter(name={'like_': deployment_name}),
            sort=FlowRunSort.START_TIME_DESC,
            limit=most_recent_n if not delete_remaining else None
        )

        if not flow_runs:
            print(f"No flow runs found in states: {states!r}")
            return []
        
        rescheduled_flow_runs: list[FlowRun] = []
        for i, run in enumerate(flow_runs):
            await client.delete_flow_run(flow_run_id=run.id)
            if i < most_recent_n:
                new_run = await client.create_flow_run_from_deployment(
                    deployment_id=run.deployment_id,
                    state=Scheduled(scheduled_time=run.expected_start_time + delay),
                )
                rescheduled_flow_runs.append(new_run)
            
        return rescheduled_flow_runs


if __name__ == "__main__":
    rescheduled_flow_runs = asyncio.run(
        reschedule_late_flow_runs(
            deployment_name="healthcheck-storage-test",
            delay=timedelta(hours=6),
            most_recent_n=3,
        )
    )
    
    print(f"Rescheduled {len(rescheduled_flow_runs)} flow runs")
    
    assert all(run.state.is_scheduled() for run in rescheduled_flow_runs)
    assert all(
        run.expected_start_time > datetime.now(timezone.utc)
        for run in rescheduled_flow_runs
    )
```

</Accordion>

### ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‹ã‚‰æœ€æ–°ã® `N` ä»¶ã®å®Œäº†ã—ãŸãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å–å¾—ã—ã¾ã™ã€‚

ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‹ã‚‰æœ€æ–°ã® `N` ä»¶ã®å®Œäº†ã—ãŸãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å–å¾—ã™ã‚‹ã«ã¯ã€`read_flow_runs` ã¨ `prefect.client.schemas` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

æ¬¡ã®ä¾‹ã§ã¯ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‹ã‚‰æœ€æ–°ã® 3 ä»¶ã®å®Œäº†ã—ãŸãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å–å¾—ã—ã¾ã™:

```python
async def get_most_recent_flow_runs(
    n: int,
    states: list[str] | None = None
) -> list[FlowRun]:    
    async with get_client() as client:
        return await client.read_flow_runs(
            flow_run_filter=FlowRunFilter(
                state={'type': {'any_': states or ["COMPLETED"]}}
            ),
            sort=FlowRunSort.END_TIME_DESC,
            limit=n,
        )
```

ã“ã‚Œã‚’ä½¿ç”¨ã—ã¦ã€æœ€å¾Œã«å®Œäº†ã—ãŸ 3 å›ã®å®Ÿè¡Œã‚’å–å¾—ã—ã¾ã™:

```python
flow_runs: list[FlowRun] = asyncio.run(
    get_most_recent_flow_runs(n=3)
)
```

<Accordion title="View the complete example">

```python get_recent_flows.py
from __future__ import annotations

import asyncio

from prefect import get_client
from prefect.client.schemas.filters import FlowRunFilter
from prefect.client.schemas.objects import FlowRun
from prefect.client.schemas.sorting import FlowRunSort

async def get_most_recent_flow_runs(
    n: int,
    states: list[str] | None = None
) -> list[FlowRun]:    
    async with get_client() as client:
        return await client.read_flow_runs(
            flow_run_filter=FlowRunFilter(
                state={'type': {'any_': states or ["COMPLETED"]}}
            ),
            sort=FlowRunSort.END_TIME_DESC,
            limit=n,
        )


if __name__ == "__main__":
    flow_runs: list[FlowRun] = asyncio.run(
        get_most_recent_flow_runs(n=3)
    )
    assert len(flow_runs) == 3
    
    assert all(
        run.state.is_completed() for run in flow_runs
    )
    assert (
        end_times := [run.end_time for run in flow_runs]
    ) == sorted(end_times, reverse=True)
```

</Accordion>

ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å…¨ä½“ã®æœ€å¾Œã® 3 ã¤ã§ã¯ãªãã€`DeploymentFilter` ã‚’ä½¿ç”¨ã—ã¦ã€ç‰¹å®šã®ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®æœ€å¾Œã® 3 ã¤ã®å®Œäº†ã—ãŸãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

### ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä»‹ã—ã¦ã€å®Ÿè¡Œä¸­ã®ã™ã¹ã¦ã®ãƒ•ãƒ­ãƒ¼ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«çŠ¶æ…‹ã«é·ç§»ã•ã›ã¾ã™

`get_client` ã‚’ä½¿ç”¨ã—ã¦ã€è¤‡æ•°ã®å®Ÿè¡Œã‚’ `Canceled` çŠ¶æ…‹ã«è¨­å®šã—ã¾ã™ã€‚
ã“ã®ä¾‹ã§ã¯ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œæ™‚ã« `Pending`ã€`Running`ã€`Scheduled`ã€ã¾ãŸã¯ `Late` çŠ¶æ…‹ã«ã‚ã‚‹ã™ã¹ã¦ã®ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚

```python
async def list_flow_runs_with_states(states: list[str]) -> list[FlowRun]:
    async with get_client() as client:
        return await client.read_flow_runs(
            flow_run_filter=FlowRunFilter(
                state=FlowRunFilterState(
                    name=FlowRunFilterStateName(any_=states)
                )
            )
        )

async def cancel_flow_runs(flow_runs: list[FlowRun]):
    async with get_client() as client:
        for flow_run in flow_runs:
            state = flow_run.state.copy(
                update={"name": "Cancelled", "type": StateType.CANCELLED}
            )
            await client.set_flow_run_state(flow_run.id, state, force=True)
```

Cancel all pending, running, scheduled or late flows:

```python
async def bulk_cancel_flow_runs():
    states = ["Pending", "Running", "Scheduled", "Late"]
    flow_runs = await list_flow_runs_with_states(states)

    while flow_runs:
        print(f"Cancelling {len(flow_runs)} flow runs")
        await cancel_flow_runs(flow_runs)
        flow_runs = await list_flow_runs_with_states(states)

asyncio.run(bulk_cancel_flow_runs())
```

<Accordion title="View the complete example">

```python cancel_flows.py
import asyncio

from prefect import get_client
from prefect.client.schemas.filters import FlowRunFilter, FlowRunFilterState, FlowRunFilterStateName
from prefect.client.schemas.objects import FlowRun, StateType

async def list_flow_runs_with_states(states: list[str]) -> list[FlowRun]:
    async with get_client() as client:
        return await client.read_flow_runs(
            flow_run_filter=FlowRunFilter(
                state=FlowRunFilterState(
                    name=FlowRunFilterStateName(any_=states)
                )
            )
        )


async def cancel_flow_runs(flow_runs: list[FlowRun]):
    async with get_client() as client:
        for idx, flow_run in enumerate(flow_runs):
            print(f"[{idx + 1}] Cancelling flow run '{flow_run.name}' with ID '{flow_run.id}'")
            state_updates: dict[str, str] = {}
            state_updates.setdefault("name", "Cancelled")
            state_updates.setdefault("type", StateType.CANCELLED)
            state = flow_run.state.copy(update=state_updates)
            await client.set_flow_run_state(flow_run.id, state, force=True)


async def bulk_cancel_flow_runs():
    states = ["Pending", "Running", "Scheduled", "Late"]
    flow_runs = await list_flow_runs_with_states(states)

    while len(flow_runs) > 0:
        print(f"Cancelling {len(flow_runs)} flow runs\n")
        await cancel_flow_runs(flow_runs)
        flow_runs = await list_flow_runs_with_states(states)
    print("Done!")


if __name__ == "__main__":
    asyncio.run(bulk_cancel_flow_runs())
```

</Accordion>
